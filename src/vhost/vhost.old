#include "vhost.h"

#include <stdio.h>

#define MAX_EVENTS 10
#define NB_MAX_CLIENTS 4096

struct vhost *create_vhost(const struct global_config *global_config,
                           struct vhost_config *vhost_config)
{
    struct vhost *host = malloc(sizeof(struct vhost));

    if (host == NULL)
        return NULL;

    host->global_config = global_config;
    host->vhost_config = vhost_config;

    return host;
}

static struct http_message *
execute_request(struct http_message *message, struct hash_map *headers,
                const struct vhost_config *vhost_config, char *reasons[])
{
    char *filename = vhost_config->default_file;

    char *target = message->start_line.line.request->target;

    int filefd = -1;
    int size = -1;

    char path[4096] = { 0 };

    enum status_code code;

    concat_path(path, vhost_config->root_dir, target);

    if (is_regular_file(path))
    {
        filefd = open(path, O_RDONLY);
        code = OK;
    }
    else
    {
        strcat(path, filename);

        if (!is_regular_file(path))
            code = NOT_FOUND;
        else
        {
            filefd = open(path, O_RDONLY);
            code = OK;
        }
    }

    if (filefd == -1 && code == OK)
        code = FORBIDDEN;
    else
        size = size_of_file(filefd);
    struct http_message *answer = create_http_message(
        create_start_line(
            create_http_line(
                NULL, create_http_status(HTTP_VERSION, code, reasons[code])),
            STATUS),
        headers, "");
    if (code == OK)
    {
        answer->file_to_serve = filefd;
        answer->file_size = size;
        if (message->start_line.line.request->method == GET)
        {
            answer->file_to_serve = filefd;
            answer->file_size = size;
        }
        else
            close(filefd);
    }
    else
        size = 0;

    char *length = calloc(16, sizeof(char));
    sprintf(length, "%d", size);

    hash_map_insert(headers, "Content-Length", length, NULL);

    return answer;
}

static void write_answer(FILE *stream, struct http_message *answer)
{
    struct http_status *status = answer->start_line.line.status;

    fprintf(stream, "%s %d %s\r\n", status->http_version, status->code,
            status->reason);

    hash_map_dump(stream, answer->headers);
    if (fprintf(stream, "\r\n") < 0)
    {
        if (answer->file_to_serve != -1)
        {
            close(answer->file_to_serve);
            return;
        }
    }

    if (answer->file_to_serve != -1)
    {
        if (fflush(stream) != 0)
        {
            close(answer->file_to_serve);
            return;
        }
        sendfile(fileno(stream), answer->file_to_serve, NULL,
                 answer->file_size);
        close(answer->file_to_serve);
    }
    else
    {
        fprintf(stream, "%s", answer->body);
    }
}

static void answer_client(struct http_message *message, FILE *stream,
                          const struct vhost_config *vhost_config,
                          struct sockaddr ip)
{
    struct hash_map *headers = hash_map_init(STD_NB_HEADERS);

    char date[4096] = { 0 };
    time_t current_time = time(NULL);
    struct tm *tm = gmtime(&current_time);
    char hostname[4096] = { 0 };

    strftime(date, 4096, "%a, %e %b %Y %H:%M:%S GMT", tm);

    strcat(hostname, vhost_config->ip);
    strcat(hostname, ":");
    strcat(hostname, vhost_config->port);

    hash_map_insert(headers, "Date", date, NULL);
    hash_map_insert(headers, "Connexion", "close", NULL);
    hash_map_insert(headers, "Host", hostname, NULL);
    CREATE_REASON;

    enum status_code code = OK;
    char *incoming_host = NULL;

    struct http_message *answer = NULL;

    if (message == NULL)
    {
        code = BAD_REQUEST;
    }
    else if (message->start_line.line.request->method == METHOD_ERROR)
        code = NOT_ALLOWED;
    else if (strncmp(message->start_line.line.request->http_version,
                     HTTP_VERSION, 7))
        code = NOT_SUPPORTED;
    else if ((incoming_host = hash_map_get(message->headers, "host")) == NULL)
    {
        printf("Didn't found key header host\n");
        code = BAD_REQUEST;
    }
    else if (strcmp(incoming_host, hostname))
        code = BAD_REQUEST;

    if (code != OK)
    {
        answer = create_http_message(
            create_start_line(
                create_http_line(NULL,
                                 create_http_status(HTTP_VERSION, code,
                                                    reasons[code])),
                STATUS),
            headers, ""); 
    }
    else
    {
        answer = execute_request(message, headers, vhost_config, reasons);
    }

    print_message(answer);

    write_answer(stream, answer);
    void *tmp = &ip;
    struct sockaddr_in *ip_addr = tmp;

    print_request(message->start_line.line.request,
                    answer->start_line.line.status,
                    vhost_config,
                  inet_ntoa(ip_addr->sin_addr));

    print_response(message->start_line.line.request,
                   answer->start_line.line.status, vhost_config,
                   inet_ntoa(ip_addr->sin_addr));

    char *length = hash_map_get(answer->headers, "Content-Length");

    if (length)
        free(length);

    free_http_message(answer);
}

void process_socket_com(int socketfd, const struct vhost_config *vhost_config,
                        struct sockaddr ip)
{
    // transform the socketfd into a stream with fdopen
    // get the parsed message with parse_message(stream)
    // for now just print the message with following:
    // dump headers hashmap
    // print body

    FILE *stream = fdopen(socketfd, "r+");
    if (!stream)
    {
        warn("stream could not be opened : socketfd = %d", socketfd);
        return;
    }

    printf("Opened stream at host: %s, socketfd = %d\n",
           vhost_config->server_name, socketfd);
    bool err = false;
    struct http_message *message = parse_message(stream, &err);

    if (message == NULL && !err)
        return;

    print_message(message);
    answer_client(message, stream, vhost_config, ip);

    free_http_message(message);

    fclose(stream);
}

static void set_non_blocking(int fd)
{
    fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);
}

void run_vhost(struct vhost *host, struct linked_list *job_queue, bool *running)
{
    struct addrinfo hints;
    struct addrinfo *res;
    int sockfd;
    int client_fd;

    struct sockaddr *clients[NB_MAX_CLIENTS] = { NULL };
    int client_fds[NB_MAX_CLIENTS] = { -1 };

    memset(client_fds, -1, NB_MAX_CLIENTS * sizeof(int));
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;


    int err;
    if ((err = getaddrinfo(host->vhost_config->ip, host->vhost_config->port,
                    &hints, &res)) != 0)
    {
        printf(gai_strerror(err));
        return;
    }

    for (; res != NULL; res = res->ai_next)
    {
        if ((sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol))
            == -1)
        {
            perror("socket");
            return;
        }
        
        int yes = 1;
        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)
        {
            perror("setsockopt");
            return;
        } 

        if (bind(sockfd, res->ai_addr, res->ai_addrlen) != -1)
            break;
    
        close(sockfd);
        sockfd = -1;
    }
    if (sockfd == -1)
    {
        perror("bind");
        return;
    }
    set_non_blocking(sockfd);
    if (listen(sockfd, 10) == -1)
    {
        perror("listen");
        return;
    }

    struct epoll_event ev;
    struct epoll_event events[MAX_EVENTS];

    int epollfd = epoll_create1(0);
    if (epollfd == -1)
    {
        perror("epoll_create1");
        return;
    }

    ev.events = EPOLLIN;
    ev.data.fd = sockfd;

    if (epoll_ctl(epollfd, EPOLL_CTL_ADD, sockfd, &ev) == -1)
    {
        perror("epoll_ctl: sockfd");
        return;
    }

    while (*running)
    {
        int nfds = epoll_wait(epollfd, events, MAX_EVENTS, 3000);
        if (nfds == -1)
        {
            perror("epoll_wait");
            return;
        }

        for (int n = 0; n < nfds; n++)
        {
            if (events[n].data.fd == sockfd)
            {
                printf("New interaction with server socket\n");
                struct sockaddr client;
                socklen_t addr_size;
                if ((client_fd = accept(sockfd, &client, &addr_size)) == -1)
                {
                    perror("accept");
                    continue;
                }
                int index = find(client_fds, NB_MAX_CLIENTS, -1);
                if (index == -1)
                {
                    printf("ahhhh\n");
                    // we're fucked
                    // TODO: clean exit
                    return;
                }
                set_non_blocking(client_fd);
                ev.events = EPOLLIN | EPOLLET;
                ev.data.fd = client_fd;
                clients[index] = malloc(sizeof(struct sockaddr));
                memcpy(clients[index], &client, sizeof(struct sockaddr));
                client_fds[index] = client_fd;
                epoll_ctl(epollfd, EPOLL_CTL_ADD, client_fd, &ev);
                printf("Added new client to epoll\n");
                continue;
            }
            // else it is a client socket
            printf("New interaction with client socket\n");
            int index = find(client_fds, NB_MAX_CLIENTS, events[n].data.fd);
            if (index == -1)
            {
                // what the fuck
                // TODO: clean exit
                return;
            }
            struct sockaddr client;
            memcpy(&client, clients[index], sizeof(struct sockaddr));
            free(clients[index]);
            client_fds[index] = -1;
            void *arg[3];
            arg[0] = &events[n].data.fd;
            arg[1] = host->vhost_config;
            arg[2] = &client;
            union job_func jobfunc;
            jobfunc.process_socket_com = process_socket_com;
            struct job *job = create_job(arg, PROCESS_SOCKET, jobfunc);
            job_queue = list_append(job_queue, job);
        }
    }
    free_vhost(host);
    close(sockfd);
    freeaddrinfo(res);
}

void free_vhost(void *vhost)
{
    struct vhost *host = vhost;
    if (host == NULL)
        return;

    free_vhost_config(host->vhost_config);
    free(host);
}
